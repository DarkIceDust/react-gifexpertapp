{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setinputValue","onSubmit","event","preventDefault","trim","length","categories","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","console","log","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"2MAIaA,EAAc,SAAC,GAAyB,IAAtBC,EAAqB,EAArBA,cAAqB,EAGZC,mBAAS,IAHG,mBAGzCC,EAHyC,KAG7BC,EAH6B,KAkChD,OACI,sBAAMC,SAvBW,SAACC,GAClBA,EAAMC,iBAIDJ,EAAWK,OAAOC,OAAS,IAO5BR,GAAgB,SAAAS,GAAU,OAAMP,GAAN,mBAAqBO,OAC/CN,EAAc,MAUlB,SACI,uBACIO,KAAO,OACPC,MAAUT,EACVU,SAjCc,SAACP,GAEvBF,EAAeE,EAAMQ,OAAOF,a,+BCVvBG,EAAO,uCAAG,WAAQC,GAAR,uBAAAC,EAAA,6DAIbC,EAJa,iDAIoCC,UAAWH,GAJ/C,+DAKAI,MAAQF,GALR,cAKbG,EALa,gBAMEA,EAAKC,OANP,uBAMZC,EANY,EAMZA,KAIDC,EAAOD,EAAKE,KAAK,SAAAC,GACnB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAKQ,EAAIG,OAAOC,iBAAiBZ,QAdtB,kBAsBZM,GAtBY,4CAAH,sDCEPO,EAAc,SAAC,GAA0B,IAAvBJ,EAAsB,EAAtBA,GAAIC,EAAkB,EAAlBA,MAAOV,EAAW,EAAXA,IAUtC,OANAc,QAAQC,IAAKN,EAAIC,EAAOV,GAOpB,sBAAKgB,UAAU,yCAAf,UACI,qBAAKC,IAAQjB,EAAMkB,IAAQR,IAC3B,kCAAMA,EAAN,WCbCS,EAAU,SAAC,GAAmB,IAAhBrB,EAAe,EAAfA,SAAe,ECId,SAAEA,GAAe,IAAD,EAEdd,mBAAS,CAC/BqB,KAAM,GACNe,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KA+BxC,OAxBAC,qBAAW,WAEX1B,EAASC,GACJ0B,MAAO,SAAAC,GAKAH,EAAS,CACLjB,KAAMoB,EACNL,SAAS,SAKtB,CAACtB,IASGuB,ED1B0BK,CAAc5B,GAAlCa,EATyB,EAS9BN,KAAae,EATiB,EASjBA,QAoCrB,OACI,qCACA,qBAAIJ,UAAY,oCAAhB,cAAuDlB,EAAvD,OACEsB,GAAW,mBAAGJ,UAAY,mCAAf,6BACb,qBAAKA,UAAU,YAAf,SAEYL,EAAOJ,KAAK,SAAEC,GAAF,OACR,cAAC,EAAD,eAEKA,GADGA,EAAIC,aEpDvBkB,EAAe,WAAM,MAOM3C,mBAAS,CAAC,cAPhB,mBAOvBQ,EAPuB,KAOXT,EAPW,KAkB9B,OACI,qCACI,8CACA,cAAC,EAAD,CAAaA,cAAkBA,IAC/B,uBAIA,6BAcQS,EAAWe,KAAM,SAAAT,GAAQ,OACrB,cAAC,EAAD,CAEAA,SAAaA,GADLA,YC1ChC8B,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.9de62de0.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\n// Mandamos el valor de setCategories como argumento ya que lo necesitamos para el handleSubmit.\r\nexport const AddCategory = ( { setCategories } ) => {\r\n\r\n    // Nos creamos un useState que nos va a servir para saber lo que la persona esté escribiendo.\r\n    const [inputValue, setinputValue] = useState('');\r\n\r\n    // Esta función servirá para que podamos cambiar el texto que haya en el input de texto.\r\n    const handleInputChange = (event) => {\r\n        // console.log(event.target.value);\r\n        setinputValue (event.target.value);\r\n    }\r\n\r\n    // Esta función sirve para que cuando presionemos la tecla Enter, no haga un refresco de la página (eso se previene con el event.preventDefault). El refresco de la página lo hace por defecto el formulario, por lo que con esto lo podemos desactivar.\r\n    const handleSubmit = (event) => {\r\n        event.preventDefault();\r\n        // console.log('Submit hecho');\r\n\r\n        // Aqui haremos una validación para que no se añada al arreglo si se pulsa la tecla enter sin escribir nada.\r\n        if ( inputValue.trim().length > 2 ) {\r\n\r\n            // Ahora llamamos al setCategories con las categorias anteriores y añadimos el inputValue que es lo que la persona escribe en el cuadro de texto.\r\n            // Cuando pulse enter, llamará a la función setCategories del GifExpertApp.js y añadirá lo nuevo al array.\r\n            // setCategories ( categories => [ ...categories, inputValue ] );\r\n\r\n            // Lo anterior está bien, pero si llegamos al punto de que queremos tener como primera la última categoría que hayamos introducido, hay que cambiar los elementos de lugar tal que así:\r\n            setCategories ( categories => [ inputValue, ...categories ])\r\n            setinputValue('');\r\n        }\r\n    \r\n    \r\n    }\r\n\r\n    // Nos creamos un input y añadimos tanto el tipo de input, como el valor y el onChange, que llamará a handleInputChange cada vez que la caja de texto cambie.\r\n    // Teníamos fragments, pero los podemos quitar ya que como agrupador vamos a usar un elemento form, al cual\r\n    // le diremos que cada vez que pulsemos la tecla enter llame al handleSubmit.\r\n    return (\r\n        <form onSubmit = { handleSubmit }>\r\n            <input \r\n                type = \"text\"\r\n                value = { inputValue }\r\n                onChange = { handleInputChange }\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\n// Utilizamos los proptypes para que se tenga que usar obligatoriamente el setCategories como componente de nuestra aplicación.\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired,\r\n}","\r\n\r\nexport const getGifs = async ( category ) => {\r\n\r\n    // Aquí es donde haremos la petición HTTP. Esto lo  haremos teniendo en cuenta que queremos que muestre los gifs de lo que nosotros escribamos.\r\n    // Por tanto, utilizamos primero el encodeURL para que nos ayude con el tema de espacios y demás y enviamos la categoría.\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=jQ73noLQDRZPGXYJ3qOEE9WGxUSxcGKy`;\r\n    const resp = await fetch ( url );\r\n    const {data} = await resp.json();\r\n\r\n    // Y aquí es donde vamos a recorrer el arreglo con los gifs, donde queremos que devuelva un array con\r\n    // el id, titulo y url de dichos gifs.\r\n    const gifs = data.map( img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images.downsized_medium.url\r\n        }\r\n    })\r\n\r\n    // console.log(data);\r\n    // console.log( gifs );\r\n    // setImages( gifs );\r\n\r\n    return gifs;\r\n}","import React from 'react'\r\n\r\n// Desde aqui es desde donde mostraremos las imágenes.\r\n\r\nexport const GifGridItem = ( { id, title, url } ) => {\r\n\r\n    // Podemos mostrar el id, titulo y url en consola así o de la siguiente forma:\r\n    // console.log ( {id, title, url })\r\n    console.log( id, title, url );\r\n\r\n    // Y en este return, creando dos etiquetas, una para mostrar imagenes con el url como source, y\r\n    // un párrafo con el título de la imagen.\r\n    // Utilizamos className en vez de class para especificarle a JavaScript que\r\n    // se trata de una clase de CSS, y no del propio Javascript (class es una palabra reservada de Javascript).\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            <img src = { url } alt = { title } />\r\n            <p> { title } </p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ( { category }) => {\r\n\r\n    // // Este useState sirve para hacer las pruebas con el return de abajo.\r\n    // // const [count, setCount] = useState(0);\r\n\r\n    // const [images, setImages] = useState([]);\r\n\r\n    // Así es como usaríamos el custom Hook:\r\n    // Podemos cambiar el nombre de data a images para que sea mas facil.\r\n    const { data:images, loading } = useFetchGifs( category );\r\n    // console.log( data, loading  );\r\n    \r\n    // // Haciendo uso del useEffect, y llamando a getGifs desde aquí, nos aseguramos de que el botón que hay en el return del comentario de abajo\r\n    // // cuando lo pulsemos no vuelva a hacer la petición fetch por cada una de las pulsaciones que hagamos sobre dicho botón, sino que\r\n    // // simplemente la hace 1 vez. Este useEffect recibe dos argumentos, una función y una lista de dependencias (un arreglo). Al no haber enviado nada\r\n    // // en dicha lista, el useEffect solo se ejecuta una vez y por tanto, solamente vemos en la consola 1 vez el mensaaje con el array de 10 elementos.\r\n    // useEffect( () => {\r\n    //     getGifs( category )\r\n    //         .then ( imgs => setImages( imgs ));\r\n    // }, [] )\r\n\r\n\r\n\r\n    // En este return lo que hacemos es recorrer el array de imagenes que tiene como elementos el id, el titulo y el url,\r\n    // y le decimos que queremos que muestre en una lista como key el id, y como elemento de la lista, el titulo del gif.\r\n    // Cabe destacar que he realizado la desestructuración de id y title. Sin desestructuración sería asi:\r\n    //images.map( ( img ) => (\r\n    //     <li key = { img.id } > { img.title } </li>\r\n    //     )\r\n    // )\r\n\r\n    // Este return es anterior al componente GifGridItem.js.\r\n    // return (\r\n    //     <div>\r\n    //         <h3> { category } </h3>\r\n    //             {\r\n    //                 images.map( ({ id, title } ) => (\r\n    //                     <li key = { id } > { title } </li>\r\n    //                     )\r\n    //                 )\r\n    //             }\r\n    //     </div>\r\n    // )\r\n\r\n\r\n    return (\r\n        <>\r\n        <h3 className = \"animate__animated animate__fadeIn\"> { category } </h3>\r\n        { loading && <p className = \"animate__animated animate__flash\">Loading GIFs...</p> }\r\n        <div className=\"card-grid\"> \r\n                {\r\n                    images.map( ( img ) => (\r\n                        <GifGridItem \r\n                        key = { img.id }\r\n                        { ...img }\r\n                        />\r\n                \r\n                    ))\r\n                }\r\n        </div>\r\n        </>\r\n    )\r\n\r\n    \r\n    // Este return nos serviría para hacer pruebas, de tal forma que así podemos comprobar que necesitamos usar el\r\n    // useEffect, debido a que cada vez que pulsemos en el botón, nos vuelve a hacer la llamada a getGifs():\r\n    // return (\r\n    //     <div>\r\n    //         <h3> { count } </h3>\r\n    //         <button onClick = { () => setCount ( count + 1 ) } />\r\n    //     </div>\r\n    // )\r\n}\r\n","\r\n// Importante tener en cuenta que todos los hooks empiezan con el nombre reservado \"use\".\r\n\r\nimport { useState, useEffect } from \"react\"\r\nimport { getGifs } from \"../helpers/getGifs\";\r\n\r\n// Un hook no es más que una función.\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    useEffect( () => {\r\n\r\n    getGifs( category )\r\n        .then ( imgs => {\r\n\r\n            // setTimeout(() => {\r\n\r\n                // console.log(imgs);\r\n                setState({\r\n                    data: imgs,\r\n                    loading: false\r\n                })\r\n\r\n            // }, 3000);\r\n        });\r\n    }, [category] )\r\n\r\n    // setTimeout(() => {\r\n    //     setState({\r\n    //         data: [1,2,3,4,5,6,7],\r\n    //         loading: false\r\n    //     })\r\n    // }, 3000);\r\n\r\n    return state; // { data: [], loading: true }\r\n}","\r\nimport React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n   \r\n    // Vamos a crear una lista de categorías para nuestra aplicación.\r\n    // const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n    \r\n    // Podemos crearla como arriba, pero hay un problema, ya que podríamos llegar a modificar el arreglo y\r\n    // haciéndolo así no nos serviría. Por tanto, haremos uso del useState:\r\n    const [categories, setCategories] = useState(['One Punch']);\r\n\r\n    // const handleAdd = () => {\r\n    //     // Asi es como podemos añadir un nuevo elemento a nuestra lista de categorías (con el operador spread \"...\"), sin perder los elementos que teníamos anteriormente.\r\n    //     setCategories( [ ...categories, 'HunterXHunter' ] ); \r\n\r\n    //     // Otra forma de hacerlo:\r\n    //     // setCategories ( categories => [ ...categories, 'HunterXHunter' ] );\r\n    // }\r\n\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories = { setCategories }/>\r\n            <hr />\r\n\r\n            {/* <button onClick = { handleAdd }> Agregar </button> */}\r\n\r\n            <ol>\r\n                {\r\n                    // Nos creamos una lista ordenada con ol, y ponemos lo siguiente:\r\n                    // Con el map podemos barrer el arreglo, y le decimos que queremos devolver\r\n                    // varios li (dependerá del número de elementos que tenga el arreglo category),\r\n                    // que utilice como índice el índice del map y como elemento, muestre cada elemento\r\n                    // que se encuentra en el arreglo category.\r\n                    // categories.map( category => {\r\n                    //    return <li key={category}>{category}</li>\r\n                    // })\r\n\r\n                    // El categories.map anterior es para iniciar la app. Este es para llamar a los GIFs.\r\n                    // Llamamos a GifGrid y ponemos como key la categoría y como valor de la categoría, category también, ya que\r\n                    // utilizará el setCategories.\r\n                    categories.map ( category => (\r\n                        <GifGrid \r\n                        key = { category }\r\n                        category = { category }\r\n                        />\r\n                    ))\r\n                }\r\n            </ol>\r\n\r\n        </>\r\n        \r\n    );\r\n\r\n};\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { GifExpertApp } from './GifExpertApp';\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}